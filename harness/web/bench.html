<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAssembly Benchmark Harness</title>
    <!-- Prevent favicon.ico 404 errors during testing -->
    <link rel="icon" href="data:,">
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            font-size: 12px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .status {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px;
            background: #333;
            border-radius: 3px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            width: 0%;
            transition: width 0.3s ease;
        }
        .results {
            margin: 20px 0;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log {
            font-size: 10px;
            color: #888;
            margin: 2px 0;
        }
        .error {
            color: #ff4444;
        }
        .success {
            color: #44ff44;
        }
        .warning {
            color: #ffff44;
        }
        #memory-usage {
            color: #ff8800;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü¶Ä WASM BENCHMARK HARNESS üêπ</h1>
            <div>Rust vs TinyGo Performance Comparison</div>
        </div>
        
        <div class="status">
            <span>Status: <span id="status">Initializing...</span></span>
            <span>Memory: <span id="memory-usage">0 MB</span></span>
            <span>Time: <span id="elapsed-time">0.0s</span></span>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        
        <div class="status">
            <span>Task: <span id="current-task">None</span></span>
            <span>Language: <span id="current-lang">None</span></span>
            <span>Run: <span id="current-run">0/0</span></span>
        </div>
        
        <div class="results" id="results">
            <div class="log">Benchmark harness initialized. Waiting for commands...</div>
        </div>
        
        <div class="status">
            <span>Total Runs: <span id="total-runs">0</span></span>
            <span>Successful: <span id="successful-runs">0</span></span>
            <span>Failed: <span id="failed-runs">0</span></span>
        </div>
    </div>

    <!-- WebAssembly modules will be loaded here -->
    <div id="wasm-container" class="hidden"></div>
    
    <!-- Load benchmark modules -->
    <script type="module" src="./wasm_loader.js"></script>
    <script type="module" src="./config_loader.js"></script>
    <script type="module" src="./bench.js"></script>
    
    <script>
        // Global state for Puppeteer communication
        window.benchmarkState = {
            status: 'initializing',
            progress: 0,
            currentTask: null,
            currentLang: null,
            currentRun: 0,
            totalRuns: 0,
            successfulRuns: 0,
            failedRuns: 0,
            results: [],
            memoryUsage: 0,
            startTime: performance.now(),
            // Additional state for improved error handling
            lastError: null,
            errorCount: 0,
            detailedMetrics: false,
            taskTimeout: 30000
        };
        
        // Update UI elements
        function updateUI() {
            const state = window.benchmarkState;
            document.getElementById('status').textContent = state.status;
            document.getElementById('current-task').textContent = state.currentTask || 'None';
            document.getElementById('current-lang').textContent = state.currentLang || 'None';
            document.getElementById('current-run').textContent = `${state.currentRun}/${state.totalRuns}`;
            document.getElementById('total-runs').textContent = state.totalRuns;
            document.getElementById('successful-runs').textContent = state.successfulRuns;
            document.getElementById('failed-runs').textContent = state.failedRuns;
            document.getElementById('progress').style.width = `${state.progress}%`;
            document.getElementById('elapsed-time').textContent = `${((performance.now() - state.startTime) / 1000).toFixed(1)}s`;
            
            // Update memory if available
            if (performance.memory) {
                const memMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                document.getElementById('memory-usage').textContent = `${memMB} MB`;
                state.memoryUsage = parseFloat(memMB);
            }
        }
        
        // Log function for results with improved error tracking
        window.logResult = function(message, type = 'log') {
            try {
                const resultsDiv = document.getElementById('results');
                if (!resultsDiv) {
                    console.warn('Results div not found, falling back to console:', message);
                    console.log(`[${type.toUpperCase()}]`, message);
                    return;
                }
                
                const logDiv = document.createElement('div');
                logDiv.className = `log ${type}`;
                logDiv.textContent = `[${new Date().toISOString().slice(11, 23)}] ${message}`;
                resultsDiv.appendChild(logDiv);
                resultsDiv.scrollTop = resultsDiv.scrollHeight;
                
                // Track errors for debugging
                if (type === 'error') {
                    window.benchmarkState.lastError = message;
                    window.benchmarkState.errorCount++;
                }
                
                // Limit log entries to prevent memory issues
                const logEntries = resultsDiv.getElementsByClassName('log');
                if (logEntries.length > 1000) {
                    for (let i = 0; i < 100; i++) {
                        if (logEntries[0]) {
                            resultsDiv.removeChild(logEntries[0]);
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to log result:', error, 'Original message:', message);
            }
        };
        
        // Periodic UI updates
        setInterval(updateUI, 100);
        
        // Expose benchmark runner functions globally for tests
        window.runTask = async function(taskName, language, taskData) {
            // Input validation
            if (typeof taskName !== 'string' || !taskName.trim()) {
                throw new Error('runTask: taskName must be a non-empty string');
            }
            if (typeof language !== 'string' || !language.trim()) {
                throw new Error('runTask: language must be a non-empty string');
            }
            if (!taskData || typeof taskData !== 'object') {
                throw new Error('runTask: taskData must be a valid object');
            }
            
            if (!window.benchmarkRunner) {
                throw new Error('Benchmark runner not initialized. Wait for initialization to complete.');
            }
            
            // Create task configuration from test data
            const config = {
                task: taskName,
                language: language,
                scale: 'small', // Default scale for tests
                taskConfig: {
                    scales: {
                        small: taskData
                    }
                },
                warmup_runs: 0,  // Skip warmup for tests
                measure_runs: 1, // Single run for tests
                timeout: window.benchmarkState.taskTimeout || 30000
            };
            
            try {
                const results = await window.benchmarkRunner.runTaskBenchmark(config);
                if (results && results.length > 0) {
                    return results[0]; // Return first result for single task execution
                } else {
                    // Return error result if no results
                    return {
                        success: false,
                        error: 'No results returned from benchmark',
                        task: taskName,
                        language: language,
                        executionTime: 0,
                        memoryUsed: 0,
                        resultHash: 0
                    };
                }
            } catch (error) {
                window.logResult(`runTask failed: ${error.message}`, 'error');
                return {
                    success: false,
                    error: error.message,
                    errorType: 'execution_error',
                    task: taskName,
                    language: language,
                    executionTime: 0,
                    memoryUsed: 0,
                    resultHash: 0
                };
            }
        };
        
        // Add missing functions expected by integration tests
        window.enableDetailedMetrics = function(enable) {
            window.benchmarkState.detailedMetrics = enable;
            window.logResult(`Detailed metrics ${enable ? 'enabled' : 'disabled'}`);
        };
        
        window.setTaskTimeout = function(timeoutMs) {
            window.benchmarkState.taskTimeout = timeoutMs;
            window.logResult(`Task timeout set to ${timeoutMs}ms`);
        };
        
        window.getSystemMetrics = function() {
            return {
                timestamp: Date.now(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                memory: performance.memory ? {
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                } : null,
                timing: performance.timing ? {
                    navigationStart: performance.timing.navigationStart,
                    loadEventEnd: performance.timing.loadEventEnd
                } : null
            };
        };
        
        window.getBrowserInfo = function() {
            return {
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                webdriver: navigator.webdriver,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
        };
        
        window.validateConfig = function(config) {
            const errors = [];
            
            if (!config.experiment || !config.experiment.name) {
                errors.push('Missing experiment name');
            }
            
            if (!config.environment || !config.environment.measure_runs) {
                errors.push('Missing measure_runs in environment');
            }
            
            if (!config.taskNames || !Array.isArray(config.taskNames) || config.taskNames.length === 0) {
                errors.push('Missing or empty taskNames array');
            }
            
            if (!config.enabledLanguages || !Array.isArray(config.enabledLanguages) || config.enabledLanguages.length === 0) {
                errors.push('Missing or empty enabledLanguages array');
            }
            
            return {
                valid: errors.length === 0,
                errors: errors
            };
        };
        
        // Initial log
        window.logResult('Benchmark harness loaded successfully', 'success');
    </script>
</body>
</html>