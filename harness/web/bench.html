<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAssembly Benchmark Harness</title>
    <!-- Prevent favicon.ico 404 errors during testing -->
    <link rel="icon" href="data:,">
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            font-size: 12px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .status {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px;
            background: #333;
            border-radius: 3px;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
            border: 2px solid #555;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #44ff44, #88ff88);
            width: 0%;
            transition: width 0.5s ease;
            position: relative;
        }
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-size: 14px;
            z-index: 10;
        }
        .results {
            margin: 20px 0;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log {
            font-size: 10px;
            color: #888;
            margin: 2px 0;
        }
        .error {
            color: #ff4444;
        }
        .success {
            color: #44ff44;
        }
        .warning {
            color: #ffff44;
        }
        #memory-usage {
            color: #ff8800;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü¶Ä WASM BENCHMARK HARNESS üêπ</h1>
            <div>Rust vs TinyGo Performance Comparison</div>
        </div>
        
        <div class="status">
            <span>Status: <span id="status">Initializing...</span></span>
            <span>Memory: <span id="memory-usage">0 MB</span></span>
            <span>Time: <span id="elapsed-time">0.0s</span></span>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
            <div class="progress-text" id="progress-text">0%</div>
        </div>
        
        <div class="status">
            <span>Task: <span id="current-task">None</span></span>
            <span>Language: <span id="current-lang">None</span></span>
            <span>Run: <span id="current-run">0/0</span></span>
        </div>
        
        <div class="results" id="results">
            <div class="log">Benchmark harness initialized. Waiting for commands...</div>
        </div>
        
        <div class="status">
            <span>Successful: <span id="successful-runs">0</span></span>
            <span>Failed: <span id="failed-runs">0</span></span>
        </div>
    </div>

    <!-- WebAssembly modules will be loaded here -->
    <div id="wasm-container" class="hidden"></div>
    
    <!-- Load benchmark modules -->
    <script type="module" src="./wasm_loader.js"></script>
    <script type="module" src="./config_loader.js"></script>
    <script type="module" src="./bench.js"></script>
    
    <script>
        // Global state for Puppeteer communication
        window.benchmarkState = {
            status: 'initializing',
            progress: 0,
            currentTask: null,
            currentLang: null,
            currentRun: 0,
            successfulRuns: 0,
            failedRuns: 0,
            results: [],
            memoryUsage: 0,
            startTime: performance.now(),
            endTime: null,
            // Additional state for improved error handling
            lastError: null,
            errorCount: 0,
            detailedMetrics: false,
            taskTimeout: 30000,
            uiUpdateInterval: null,
            // Enhanced state for multi-task tracking
            allTasks: [],
            completedTasks: 0,
            currentTaskIndex: 0,
            taskHistory: []
        };
        
        // Update UI elements
        function updateUI() {
            const state = window.benchmarkState;
            document.getElementById('status').textContent = state.status;
            document.getElementById('current-task').textContent = state.currentTask || 'None';
            document.getElementById('current-lang').textContent = state.currentLang || 'None';
            
            // Update current run display - always use task-based counting for consistency
            if (state.allTasks.length > 0) {
                // Use task-based tracking for consistent display
                document.getElementById('current-run').textContent = `${state.completedTasks}/${state.allTasks.length}`;
            } else {
                // Fallback when no tasks are defined yet
                document.getElementById('current-run').textContent = `0/0`;
            }
            
            document.getElementById('successful-runs').textContent = state.successfulRuns;
            document.getElementById('failed-runs').textContent = state.failedRuns;
            
            // Calculate progress - use task-based counting for consistency
            let progressPercent = 0;
            let progressText = "0%";

            if (state.allTasks.length > 0) {
                progressPercent = (state.completedTasks / state.allTasks.length) * 100;
                progressText = `${state.completedTasks}/${state.allTasks.length} (${Math.round(progressPercent)}%)`;
            } else {
                progressText = "Initializing...";
                progressPercent = 0;
            }
            
            // Ensure progress is between 0 and 100
            progressPercent = Math.min(100, Math.max(0, progressPercent));
            
            document.getElementById('progress').style.width = `${progressPercent}%`;
            document.getElementById('progress-text').textContent = progressText;

            // Calculate elapsed time - always update during running state
            let elapsedTime;
            if (state.endTime && state.status === 'benchmarks_finished') {
                // Only use endTime if benchmarks are completely finished
                elapsedTime = ((state.endTime - state.startTime) / 1000).toFixed(1);
            } else if (state.status === 'benchmarks_finished') {
                // Set final time and stop timer only when all benchmarks are done
                if (!state.endTime) {
                    state.endTime = performance.now();
                }
                elapsedTime = ((state.endTime - state.startTime) / 1000).toFixed(1);
                // Stop the UI update timer only after benchmarks are completely finished
                if (state.uiUpdateInterval) {
                    clearInterval(state.uiUpdateInterval);
                    state.uiUpdateInterval = null;
                }
            } else {
                // Continue updating timer during running, completed tasks, etc.
                elapsedTime = ((performance.now() - state.startTime) / 1000).toFixed(1);
            }
            document.getElementById('elapsed-time').textContent = `${elapsedTime}s`;

            // Update memory if available
            if (performance.memory) {
                const memMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                document.getElementById('memory-usage').textContent = `${memMB} MB`;
                state.memoryUsage = parseFloat(memMB);
            }
        }

        // Start UI update timer
        function startUIUpdates() {
            // Stop any existing timer first
            stopUIUpdates();
            
            if (!window.benchmarkState.uiUpdateInterval) {
                window.benchmarkState.uiUpdateInterval = setInterval(() => {
                    updateUI();
                }, 200); // Update every 200ms for smooth updates
                // UI update timer started
            }
        }

        // Stop UI update timer
        function stopUIUpdates() {
            if (window.benchmarkState.uiUpdateInterval) {
                clearInterval(window.benchmarkState.uiUpdateInterval);
                window.benchmarkState.uiUpdateInterval = null;
                // UI update timer stopped
            }
        }
        
        // Log function for results with improved error tracking
        window.logResult = function(message, type = 'log') {
            try {
                const resultsDiv = document.getElementById('results');
                if (!resultsDiv) {
                    console.warn('Results div not found, falling back to console:', message);
                    console.log(`[${type.toUpperCase()}]`, message);
                    return;
                }
                
                const logDiv = document.createElement('div');
                logDiv.className = `log ${type}`;
                logDiv.textContent = `[${new Date().toISOString().slice(11, 23)}] ${message}`;
                resultsDiv.appendChild(logDiv);
                resultsDiv.scrollTop = resultsDiv.scrollHeight;
                
                // Track errors for debugging
                if (type === 'error') {
                    window.benchmarkState.lastError = message;
                    window.benchmarkState.errorCount++;
                }
                
                // Limit log entries to prevent memory issues
                const logEntries = resultsDiv.getElementsByClassName('log');
                if (logEntries.length > 1000) {
                    for (let i = 0; i < 100; i++) {
                        if (logEntries[0]) {
                            resultsDiv.removeChild(logEntries[0]);
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to log result:', error, 'Original message:', message);
            }
        };
        
        // Task management functions for single-window experience
        window.initializeBenchmarkSuite = function(taskList) {
            const state = window.benchmarkState;

            // Reset all state
            state.allTasks = taskList || [];
            state.completedTasks = 0;
            state.currentTaskIndex = 0;
            state.taskHistory = [];
            state.currentRun = 0;
            state.successfulRuns = 0;
            state.failedRuns = 0;
            state.status = 'initializing';
            state.currentTask = null;
            state.currentLang = null;
            state.progress = 0;
            state.startTime = performance.now(); // Reset start time
            state.endTime = null;

            window.logResult(`Initialized benchmark suite with ${state.allTasks.length} tasks`, 'success');

            // Start UI updates and immediately update display
            startUIUpdates();
            updateUI();

            // Mark as ready after a brief moment to show initialization
            setTimeout(() => {
                state.status = 'ready';
                updateUI();
            }, 100);
        };
        
        window.startTask = function(taskName, language) {
            const state = window.benchmarkState;
            state.currentTask = taskName;
            state.currentLang = language;
            state.status = 'running';
            state.currentRun = state.completedTasks + 1; // Update current run
            
            const taskLabel = `${taskName} (${language})`;
            window.logResult(`üöÄ Starting task: ${taskLabel}`, 'log');
            updateUI();
        };
        
        window.completeTask = function(taskName, language, success, results) {
            const state = window.benchmarkState;
            state.completedTasks++;
            state.currentRun = state.completedTasks; // Update current run to match completed

            const taskLabel = `${taskName} (${language})`;
            const taskResult = {
                task: taskName,
                language: language,
                success: success,
                timestamp: new Date().toISOString(),
                results: results
            };
            state.taskHistory.push(taskResult);

            if (success) {
                state.successfulRuns++;
                window.logResult(`‚úÖ Completed: ${taskLabel}`, 'success');
            } else {
                state.failedRuns++;
                window.logResult(`‚ùå Failed: ${taskLabel}`, 'error');
            }

            // Update progress percentage
            if (state.allTasks.length > 0) {
                state.progress = (state.completedTasks / state.allTasks.length) * 100;
            }

            // Check if all tasks are completed
            if (state.completedTasks >= state.allTasks.length) {
                state.status = 'completed';
                state.currentTask = null;
                state.currentLang = null;
                window.logResult(`üéâ All tasks completed! Success: ${state.successfulRuns}/${state.completedTasks}`, 'success');

                // Show completion message in the browser
                const completionMsg = `‚úÖ Benchmark Complete!\n\nResults:\n- Total Tasks: ${state.completedTasks}\n- Successful: ${state.successfulRuns}\n- Failed: ${state.failedRuns}\n- Success Rate: ${((state.successfulRuns/state.completedTasks)*100).toFixed(1)}%\n\nYou can now inspect the detailed logs above or close this window.`;
                window.logResult(completionMsg, 'success');
            }

            updateUI();
        };

        // Function to signal that the entire benchmark suite is finished
        window.finishBenchmarkSuite = function() {
            const state = window.benchmarkState;
            state.status = 'benchmarks_finished';
            window.logResult(`üìä Benchmark suite execution finished`, 'success');
            updateUI(); // This will trigger the timer to stop
        };
        
        // Expose benchmark runner functions globally for tests
        window.runTask = async function(taskName, language, taskData) {
            // Input validation
            if (typeof taskName !== 'string' || !taskName.trim()) {
                throw new Error('runTask: taskName must be a non-empty string');
            }
            if (typeof language !== 'string' || !language.trim()) {
                throw new Error('runTask: language must be a non-empty string');
            }
            if (!taskData || typeof taskData !== 'object') {
                throw new Error('runTask: taskData must be a valid object');
            }
            
            if (!window.benchmarkRunner) {
                throw new Error('Benchmark runner not initialized. Wait for initialization to complete.');
            }
            
            // Create task configuration from test data
            const config = {
                task: taskName,
                language: language,
                scale: 'micro', // Use micro scale for tests
                taskConfig: {
                    scales: {
                        micro: taskData
                    }
                },
                warmupRuns: 0,  // Skip warmup for tests
                measureRuns: 1, // Single run for tests
                timeout: window.benchmarkState.taskTimeout || 30000
            };
            
            try {
                const results = await window.benchmarkRunner.runTaskBenchmark(config);
                if (results && results.executionTimes && results.executionTimes.length > 0) {
                    // Extract data from aggregated result for test compatibility
                    return {
                        success: true,
                        task: results.task,
                        language: results.language,
                        executionTime: results.executionTimes[0],
                        memoryUsed: results.memoryUsages ? results.memoryUsages[0] : 1024,
                        resultHash: results.resultHashes ? results.resultHashes[0] : 0,
                        timestamp: results.timestamp,
                        // Add task-specific fields based on the task type
                        ...(taskName === 'json_parse' && taskData.expectedProperties ? 
                            { recordsProcessed: taskData.expectedProperties.recordCount } : {}),
                        ...(taskName === 'matrix_mul' && taskData.expectedProperties ? 
                            { resultDimensions: taskData.expectedProperties.resultDimensions } : {})
                    };
                } else {
                    // Return error result if no results
                    return {
                        success: false,
                        error: 'No results returned from benchmark',
                        task: taskName,
                        language: language,
                        executionTime: 0,
                        memoryUsed: 0,
                        resultHash: 0
                    };
                }
            } catch (error) {
                window.logResult(`runTask failed: ${error.message}`, 'error');
                return {
                    success: false,
                    error: error.message,
                    errorType: 'execution_error',
                    task: taskName,
                    language: language,
                    executionTime: 0,
                    memoryUsed: 0,
                    resultHash: 0
                };
            }
        };
        
        // Add missing functions expected by integration tests
        window.enableDetailedMetrics = function(enable) {
            window.benchmarkState.detailedMetrics = enable;
            window.logResult(`Detailed metrics ${enable ? 'enabled' : 'disabled'}`);
        };
        
        window.setTaskTimeout = function(timeoutMs) {
            window.benchmarkState.taskTimeout = timeoutMs;
            window.logResult(`Task timeout set to ${timeoutMs}ms`);
        };
        
        window.getSystemMetrics = function() {
            return {
                timestamp: Date.now(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                memory: performance.memory ? {
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                } : null,
                timing: performance.timing ? {
                    navigationStart: performance.timing.navigationStart,
                    loadEventEnd: performance.timing.loadEventEnd
                } : null
            };
        };
        
        window.getBrowserInfo = function() {
            return {
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                webdriver: navigator.webdriver,
                maxTouchPoints: navigator.maxTouchPoints || 0
            };
        };
        
        window.validateConfig = function(config) {
            const errors = [];
            
            if (!config.experiment || !config.experiment.name) {
                errors.push('Missing experiment name');
            }
            
            if (!config.environment || !config.environment.measure_runs) {
                errors.push('Missing measure_runs in environment');
            }
            
            if (!config.taskNames || !Array.isArray(config.taskNames) || config.taskNames.length === 0) {
                errors.push('Missing or empty taskNames array');
            }
            
            if (!config.enabledLanguages || !Array.isArray(config.enabledLanguages) || config.enabledLanguages.length === 0) {
                errors.push('Missing or empty enabledLanguages array');
            }
            
            return {
                valid: errors.length === 0,
                errors: errors
            };
        };
        
        // Initial log
        window.logResult('Benchmark harness loaded successfully', 'success');

        // Start UI updates immediately when page loads
        function initializePage() {
            // Page initializing...
            
            // Reset any existing state to defaults
            window.benchmarkState.status = 'initializing';
            window.benchmarkState.startTime = performance.now();
            
            startUIUpdates();
            updateUI();
            
            // Page initialization complete, UI updates started
        }

        // Start updates when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage();
        }
    </script>
</body>
</html>